## 对象存储相关请求发送时机与涉及文件

### 一、请求类型与后端映射
- AddObjectStore / PutObjectStore → 后端 `AddOrModifyObjectToDB`
- GetObjectStore / GetTuplesObjectStore → 后端 `GetObjectFromDB` / `GetTuplesWithTypeFromDB`
- DeleteObjectStore → 后端 `DeleteObjectToDB`

涉及文件：
- `modules/dreamview_plus/frontend/packages/dreamview-core/src/services/api/types.ts`
  - 枚举到后端方法名的映射：`AddObjectStore = 'AddOrModifyObjectToDB'`, `PutObjectStore = 'AddOrModifyObjectToDB'`, `GetObjectStore`, `GetTuplesObjectStore`, `DeleteObjectStore`
- `modules/dreamview_plus/frontend/packages/dreamview-core/src/services/api/main.ts`
  - `addObjectStore(...)`
  - `putObjectStore(...)`
  - `putChartObjectStore(...)`
  - `getObjectStore(...)`
  - `getTuplesObjectStore(...)`

后端处理：
- `modules/dreamview_plus/backend/hmi/hmi_worker.cc`
  - `HMIWorker::AddOrModifyObjectToDB` → `KVDB::Put(key, value)`
  - `HMIWorker::DeleteObjectToDB` → `KVDB::Delete(key)`
  - `HMIWorker::GetObjectFromDB` → `KVDB::Get(key)`
  - `HMIWorker::GetTuplesWithTypeFromDB` → `KVDB::GetWithStart(type)`

---

### 二、什么时候发送（前端触发时机）

#### 1) 布局保存（PanelLayout）
- 触发时机：
  - 布局初始化后，用户拖拽/分割/调整导致 `currentLayout` 变化（500ms 防抖）
- 请求方法：
  - `putObjectStore({ type: mode, value: layout })` → `MainApiTypes.PutObjectStore` → AddOrModifyObjectToDB
- 涉及文件：
  - `modules/dreamview_plus/frontend/packages/dreamview-core/src/InitAppData.tsx`
    - `useInitLayout()` 中的 `debounceUpdateObject(...)` 和 `useEffect` 监听 `currentLayout`

#### 2) 图表配置保存（Charts 面板）
- 触发时机：
  - 新增图表
  - 删除图表
  - 修改图表配置（300ms 防抖）
- 请求方法：
  - `putChartObjectStore({ type: OBJECT_STORE_TYPE.CHART, panelId, value })` → `MainApiTypes.PutObjectStore` → AddOrModifyObjectToDB
- 涉及文件：
  - `modules/dreamview_plus/frontend/packages/dreamview-core/src/components/panels/Charts/hoc/useChartConfigManager.ts`
    - `putObjectStore`（debounce 300ms）
    - `onAddNewChart` / `onDeleteChart` / `updateChartConfigList`

---

### 三、请求封装（Main API）

- 文件：`modules/dreamview_plus/frontend/packages/dreamview-core/src/services/api/main.ts`
  - `addObjectStore<T>(type, panelId, value)`
  - `putObjectStore<T>({ type, value })`
  - `putChartObjectStore<T>({ type, panelId, value })`
  - `getObjectStore<T>({ type })`
  - `getTuplesObjectStore<T>({ type })`

- 文件：`modules/dreamview_plus/frontend/packages/dreamview-core/src/services/api/types.ts`
  - `MainApiTypes.AddObjectStore = 'AddOrModifyObjectToDB'`
  - `MainApiTypes.PutObjectStore = 'AddOrModifyObjectToDB'`
  - `MainApiTypes.GetObjectStore = 'GetObjectFromDB'`
  - `MainApiTypes.GetTuplesObjectStore = 'GetTuplesWithTypeFromDB'`
  - 参数接口：`IAddObjectStoreParams`, `IPutObjectStoreParams`, `IGetObjectStoreParams`, `IGetTuplesObjectStoreParams`

---

### 四、在 Offline 面板中复用的建议
- 直接调用：
  - 新增对象：`mainApi.addObjectStore(type, panelId, value)`
  - 覆盖/更新：`mainApi.putObjectStore({ type, value })`
- Key/类型约定（建议）：
  - `type` 使用已有 `OBJECT_STORE_TYPE` 或新增 `OBJECT_STORE_TYPE.OFFLINE`
  - `value` 使用 JSON 串行化结构，包含对象属性、时间戳、版本等
- 触发点：
  - OfflineAnalysis 中的“保存/更新”按钮、筛选条件变更、时间轴书签保存等

---

### 五、端到端路径概览
- Panel/Hook 触发 → `mainApi.putObjectStore/putChartObjectStore` → `MainApiTypes.PutObjectStore` → 后端 `HMIWorker::AddOrModifyObjectToDB` → `KVDB::Put` 持久化

### 前端启动时是否从后端加载 Protobuf？做了什么？

- 结论：会。前端在启动阶段通过主连接获取元数据与 proto 描述，并增量加载/解析，用于后续各数据流解码。

- 关键流程与位置
  - `modules/dreamview_plus/frontend/packages/dreamview-core/src/InitAppData.tsx`
    - `useInitWebSocket()`：监听主连接状态，收到 `ConnectionStatusEnum.METADATA` 表示已获取元数据（含通道与 proto 信息）。
    - `useInitProto()`：监听 `webSocketManager` 的初始化事件，统计与展示 proto 加载进度。
      - 事件：
        - `IEventName.ChannelTotal`：总通道数（初始化目标计数）。
        - `IEventName.ChannelChange`：每个通道 proto 解析完成回调（递减计数，推进进度）。
        - `IEventName.BaseProtoChange`：基础 proto 文件解析完成回调（递减计数）。
      - 进度条：根据通道与基础 proto 的双计数合并计算进度，直至全部完成。
  - `webSocketManager`（同目录 `src/services/WebSocketManager`）：负责
    - 初始化 proto 文件（`initProtoFiles` 列表）
    - 拉取/接收后端元数据（含通道→消息类型映射）
    - 分发上述事件并在内部缓存解析后的类型，用于后续数据流解码

- 加载了哪些 proto
  - 基础 proto（公共消息/通用类型）
  - 按通道的消息类型对应的 proto（根据后端元数据列表逐一解析）
  - 解析结果用于主/子 WebSocket 的二进制消息解码（配合 worker/off-main-thread 反序列化）

- 作用
  - 确保后续 `StreamApi` 订阅的数据流（如 HMI_STATUS、Obstacle、PointCloud、Camera 等）能以对应的 proto 类型正确解码并渲染/入库。


[1 tool called]

- 简短结论
  - 这类基础 proto（如 `apollo.common.ErrorCode`、`apollo.cyber.proto.Header`）不是在业务流里临时拉取的“通道 proto”，而是作为“基础 proto”在前端启动阶段统一加载/就绪，用于后续解码和工具能力（记录/回放、错误码解析等）。

- 何时加载
  - 应用启动后，WebSocket 主连接建立并进入元数据阶段时，前端开始初始化基础 proto 与通道 proto：
    - 基础 proto：在前端初始化流程里优先就绪（对应 “BaseProtoChange” 事件），包含常用枚举/通用结构（如 `ErrorCode`）以及 cyber 记录相关（如 `Header`）。
    - 通道 proto：依据后端元数据声明的 channel→type 映射，按需增量加载（对应 “ChannelChange” 事件）。
  - 你能看到的触发点与进度显示：
    - 文件 `modules/dreamview_plus/frontend/packages/dreamview-core/src/InitAppData.tsx`
      - `useInitWebSocket()`：主连接状态进入 `METADATA` 后开始元数据与类型就绪。
      - `useInitProto()`：监听
        - `IEventName.BaseProtoChange`：基础 proto（含 `ErrorCode`、`Header`）加载进度。
        - `IEventName.ChannelChange`：每个通道 proto 解析进度。

- 这些类型来自哪里
  - 基础类型已随包预置/打包，可在类型声明中看到，如：
    - `modules/dreamview_plus/frontend/packages/dreamview/lib/dreamview_proto_bundle.d.ts`
      - 例如 `apollo.cyber.proto.Header`（record 头信息等）
      - 常见的基础枚举/结构（如 `apollo.common.ErrorCode`）也在这一类基础 proto 中。
  - 运行期由 `webSocketManager` 完成注册和就绪，供 `StreamApi` 与解码器使用。

- 要点
  - “error_code proto / header proto”属于基础 proto，随应用启动初始化（BaseProto 阶段）统一加载；不是在某个具体面板里按需去“从后端再拉一次”。

- 简短回答: 递归加载 protobuf 在两类时机触发
  - 前端启动后主连接进入 METADATA 阶段，初始化基础 proto 与通道 proto 时由管理器递归解析依赖。
  - 动态场景（如开始/切换回放、首次订阅新通道）收到新的类型/描述符集时，按依赖关系递归补齐加载。

- 具体触发点
  - 启动阶段
    - 文件：`modules/dreamview_plus/frontend/packages/dreamview-core/src/InitAppData.tsx`
      - `useInitWebSocket()`：主连接状态到 METADATA
      - `useInitProto()`：监听 BaseProto/Channel proto 的加载进度（这里完成依赖递归装载）
  - 回放/重置后
    - 后端调用 `GetDataHandlerConf` 推送通道→类型映射与描述符，前端据此递归补齐依赖（在开始回放、重播、重置进度等时机触发）
  - 首次订阅新数据流
    - 当订阅的 channel 对应消息类型尚未就绪时，管理器按类型依赖图递归加载（包含 import 的依赖 proto）

- 负责模块
  - 原地显示进度：`InitAppData.tsx` 的 `useInitProto()`（BaseProtoChange / ChannelChange）
  - 实际递归加载与类型注册：WebSocket 管理层（主连接元数据处理、描述符集注册、类型依赖解析）